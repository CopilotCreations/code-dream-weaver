"""
Narrative Synthesizer Module

Generates prose interpretations of codebase analysis,
weaving symbolic findings into coherent psychological narratives.
"""

from dataclasses import dataclass
from typing import List, Dict, Optional
from datetime import datetime

from .ast_parser import CodeStructure
from .symbolic_ontology import SymbolicProfile, ArchetypeMatch, Archetype, get_archetype_description
from .motif_detector import MotifAnalysis, Motif
from .tension_detector import TensionAnalysis, Tension


@dataclass
class InterpretationReport:
    """Complete interpretation report in markdown format."""
    title: str
    generated_at: str
    content: str
    word_count: int


class NarrativeSynthesizer:
    """
    Synthesizes analysis results into prose narrative.
    
    Like a dream analyst weaving disparate symbols into meaning,
    this synthesizer creates coherent psychological portraits
    from scattered code patterns.
    """

    def __init__(self):
        self.report_sections: List[str] = []

    def synthesize(
        self,
        repo_path: str,
        structure: CodeStructure,
        profile: SymbolicProfile,
        motifs: MotifAnalysis,
        tensions: TensionAnalysis
    ) -> InterpretationReport:
        """Synthesize all analyses into a narrative report."""
        self.report_sections = []
        
        # Title and header
        self._add_header(repo_path, structure)
        
        # Executive summary / Introduction
        self._add_introduction(structure, profile)
        
        # Dominant archetypes section
        self._add_dominant_archetypes(profile)
        
        # Recurring motifs section
        self._add_recurring_motifs(motifs)
        
        # Unresolved tensions section
        self._add_unresolved_tensions(tensions)
        
        # Overall psychological profile
        self._add_psychological_profile(structure, profile, motifs, tensions)
        
        # Closing reflection
        self._add_closing(profile, tensions)
        
        # Combine all sections
        content = "\n\n".join(self.report_sections)
        word_count = len(content.split())
        
        return InterpretationReport(
            title=f"Dream Interpretation: {repo_path}",
            generated_at=datetime.now().isoformat(),
            content=content,
            word_count=word_count
        )

    def _add_header(self, repo_path: str, structure: CodeStructure):
        """Add report header."""
        header = f"""# Oneirocode Dream Interpretation

## Repository: `{repo_path}`

*Generated by Oneirocode — A Dream Interpreter for Software*

---

### Codebase Vital Signs

| Metric | Value |
|--------|-------|
| Files Analyzed | {structure.file_count} |
| Total Lines | {structure.total_lines:,} |
| Functions | {structure.function_count} |
| Classes | {structure.class_count} |
| Guard Clauses | {len(structure.guard_clauses)} |
| Error Handlers | {len(structure.error_handlers)} |
| Defensive Patterns | {len(structure.defensive_patterns)} |

---"""
        self.report_sections.append(header)

    def _add_introduction(self, structure: CodeStructure, profile: SymbolicProfile):
        """Add interpretive introduction."""
        # Determine overall character
        if profile.dominant_archetypes:
            primary = profile.dominant_archetypes[0].archetype.value.replace('_', ' ').title()
        else:
            primary = "undefined presence"
        
        traits_str = ", ".join(profile.behavioral_traits[:3]) if profile.behavioral_traits else "complex and multifaceted"
        
        intro = f"""## The Dream Begins

This codebase speaks in the language of symbols. Within its {structure.total_lines:,} lines and {structure.function_count} functions, patterns emerge that reveal the psychological undercurrents of its creation.

At first encounter, the code presents as a **{primary}** — its character is {traits_str.lower()}. But as we descend deeper into its structure, more complex truths reveal themselves.

What follows is not a technical review but a *symbolic interpretation* — treating code as dream content, where naming choices, structural decisions, and error handling patterns become windows into collective intent."""
        
        self.report_sections.append(intro)

    def _add_dominant_archetypes(self, profile: SymbolicProfile):
        """Add section on dominant archetypes."""
        section_parts = ["## Dominant Archetypes\n"]
        section_parts.append("*The primary symbolic figures that inhabit this code*\n")
        
        if not profile.dominant_archetypes:
            section_parts.append("The codebase is too sparse to reveal clear archetypes. It exists in a pre-symbolic state, awaiting further development to manifest its character.")
        else:
            for i, match in enumerate(profile.dominant_archetypes, 1):
                archetype_name = match.archetype.value.replace('_', ' ').title()
                strength_bar = self._create_strength_bar(match.strength)
                description = get_archetype_description(match.archetype)
                
                section_parts.append(f"### {i}. The {archetype_name}")
                section_parts.append(f"**Presence Strength:** {strength_bar} ({match.strength:.0%})\n")
                section_parts.append(f"> {description}\n")
                
                if match.evidence:
                    section_parts.append("**Evidence:**")
                    for evidence in match.evidence[:3]:
                        section_parts.append(f"- {evidence}")
                
                section_parts.append("")
        
        # Secondary archetypes brief mention
        if profile.secondary_archetypes:
            section_parts.append("### Secondary Presences\n")
            secondary_names = [m.archetype.value.replace('_', ' ').title() 
                             for m in profile.secondary_archetypes[:3]]
            section_parts.append(f"Beneath the dominant figures, we sense the influence of: **{', '.join(secondary_names)}**. These archetypes operate in the background, coloring decisions without taking center stage.")
        
        self.report_sections.append("\n".join(section_parts))

    def _add_recurring_motifs(self, motifs: MotifAnalysis):
        """Add section on recurring motifs."""
        section_parts = ["## Recurring Motifs\n"]
        section_parts.append("*The patterns that repeat, carrying amplified significance*\n")
        
        if not motifs.motifs:
            section_parts.append("The codebase lacks sufficient repetition to establish clear motifs. Each structure appears unique, resisting categorization.")
        else:
            # Group by type
            by_type: Dict[str, List[Motif]] = {}
            for motif in motifs.motifs:
                if motif.pattern_type not in by_type:
                    by_type[motif.pattern_type] = []
                by_type[motif.pattern_type].append(motif)
            
            type_labels = {
                'naming': 'Naming Motifs',
                'structural': 'Structural Motifs',
                'behavioral': 'Behavioral Motifs',
                'rhythmic': 'Rhythmic Motifs'
            }
            
            for ptype, ptype_motifs in by_type.items():
                section_parts.append(f"### {type_labels.get(ptype, ptype.title())}\n")
                
                for motif in ptype_motifs[:3]:  # Top 3 per type
                    intensity_bar = self._create_strength_bar(motif.intensity)
                    section_parts.append(f"**{motif.name}** (×{motif.occurrences})")
                    section_parts.append(f"Intensity: {intensity_bar}\n")
                    section_parts.append(f"*{motif.symbolic_meaning}*\n")
        
        # Add rhythm signature interpretation
        if motifs.rhythm_signature:
            section_parts.append("### The Rhythm Signature\n")
            section_parts.append(f"The codebase moves to a **{motifs.rhythm_signature}** rhythm. " +
                               "This tempo shapes how the code breathes and flows, " +
                               "creating the pulse underlying all other patterns.")
        
        self.report_sections.append("\n".join(section_parts))

    def _add_unresolved_tensions(self, tensions: TensionAnalysis):
        """Add section on unresolved tensions."""
        section_parts = ["## Unresolved Tensions\n"]
        section_parts.append("*The contradictions and conflicts that simmer beneath the surface*\n")
        
        if not tensions.tensions:
            section_parts.append("Remarkably, this codebase presents few obvious tensions. Either it has achieved unusual internal coherence, or its conflicts are too subtle for detection. Such peace might indicate maturity—or repression.")
        else:
            # Overall tension level
            tension_level = tensions.overall_tension_level
            if tension_level > 0.7:
                section_parts.append("⚠️ **High Tension Level Detected**\n")
                section_parts.append("This codebase carries significant internal conflict. The patterns suggest competing visions or accumulated technical debt that has become psychological weight.\n")
            elif tension_level > 0.4:
                section_parts.append("The tension level is moderate—normal for a living codebase, but worth examining.\n")
            
            for tension in tensions.tensions[:5]:  # Top 5 tensions
                severity_bar = self._create_strength_bar(tension.severity)
                section_parts.append(f"### {tension.name}")
                section_parts.append(f"**Type:** {tension.tension_type.replace('_', ' ').title()}")
                section_parts.append(f"**Severity:** {severity_bar}\n")
                section_parts.append(f"{tension.description}\n")
                section_parts.append(f"> *{tension.symbolic_interpretation}*\n")
        
        self.report_sections.append("\n".join(section_parts))

    def _add_psychological_profile(
        self,
        structure: CodeStructure,
        profile: SymbolicProfile,
        motifs: MotifAnalysis,
        tensions: TensionAnalysis
    ):
        """Add overall psychological profile synthesis."""
        section_parts = ["## Psychological Profile\n"]
        section_parts.append("*A synthesis of the codebase's character*\n")
        
        # Determine character traits
        traits = []
        
        # From archetypes
        if profile.dominant_archetypes:
            primary = profile.dominant_archetypes[0].archetype
            if primary in [Archetype.GUARDIAN, Archetype.SENTINEL, Archetype.GATEKEEPER]:
                traits.append("protective")
            elif primary in [Archetype.ANXIOUS_CARETAKER, Archetype.PERFECTIONIST]:
                traits.append("anxious")
            elif primary in [Archetype.BUILDER, Archetype.FACTORY, Archetype.ARCHITECT]:
                traits.append("generative")
            elif primary in [Archetype.SUPPRESSOR, Archetype.DENIER]:
                traits.append("avoidant")
        
        # From behavioral traits
        traits.extend(profile.behavioral_traits)
        
        # From tension level
        if tensions.overall_tension_level > 0.5:
            traits.append("conflicted")
        elif tensions.overall_tension_level < 0.2:
            traits.append("harmonious")
        
        traits_str = ", ".join(traits[:5]) if traits else "complex"
        
        # Build profile narrative
        profile_text = f"""This codebase exhibits a {traits_str} personality.

"""
        
        # Add specific observations
        if structure.guard_clauses:
            guard_ratio = len(structure.guard_clauses) / max(structure.function_count, 1)
            if guard_ratio > 0.3:
                profile_text += "**Boundary Orientation:** The code maintains strong boundaries, carefully controlling what enters its domain. "
            else:
                profile_text += "**Boundary Orientation:** The code maintains modest boundaries, allowing relatively free passage. "
        
        if structure.error_handlers:
            suppress_ratio = sum(1 for h in structure.error_handlers if h.handler_action == 'suppress') / len(structure.error_handlers)
            if suppress_ratio > 0.3:
                profile_text += "Its relationship with failure is avoidant—preferring not to acknowledge what goes wrong.\n\n"
            else:
                profile_text += "It confronts failures directly, acknowledging errors when they occur.\n\n"
        
        # Naming psychology
        if profile.naming_themes:
            top_themes = list(profile.naming_themes.keys())[:3]
            themes_str = ", ".join(f"`{t}`" for t in top_themes)
            profile_text += f"**Naming Psychology:** The recurring use of {themes_str} reveals the conceptual framework through which the code understands itself. These are not just labels but identity markers.\n\n"
        
        # Complexity relationship
        if structure.nesting_depths:
            avg_depth = sum(structure.nesting_depths) / len(structure.nesting_depths)
            if avg_depth > 3:
                profile_text += "**Complexity Relationship:** The code embraces complexity, building nested structures that reward deep exploration. It does not fear the labyrinth.\n\n"
            else:
                profile_text += "**Complexity Relationship:** The code favors simplicity, keeping structures flat and navigable. It values clarity over sophistication.\n\n"
        
        section_parts.append(profile_text)
        
        # Add a summary character description
        section_parts.append("### In Summary\n")
        
        if profile.dominant_archetypes:
            primary_archetype = profile.dominant_archetypes[0].archetype.value.replace('_', ' ').title()
            summary = f"This codebase dreams of being a **{primary_archetype}**. "
        else:
            summary = "This codebase has not yet dreamed itself into clear form. "
        
        if tensions.overall_tension_level > 0.5:
            summary += "It carries significant internal tensions—conflicts between what it aspires to be and what it has become. "
        
        if motifs.dominant_pattern:
            summary += f"Its recurring invocation of *{motifs.dominant_pattern}* reveals where its attention naturally flows. "
        
        summary += "Like all code, it is a mirror reflecting the minds that created it."
        
        section_parts.append(summary)
        
        self.report_sections.append("\n".join(section_parts))

    def _add_closing(self, profile: SymbolicProfile, tensions: TensionAnalysis):
        """Add closing reflection."""
        section_parts = ["## Closing Reflection\n"]
        
        closing = """Code is never merely functional. Every naming choice, every structural decision, every error handled or ignored carries meaning beyond its technical purpose.

This interpretation does not judge the code as good or bad, clean or messy. It simply reads the symbols present—making conscious what was unconscious in the act of creation.

"""
        
        # Add resolution suggestions if there are tensions
        if tensions.resolution_suggestions:
            closing += "### Paths Forward\n\n"
            for suggestion in tensions.resolution_suggestions[:3]:
                closing += f"- {suggestion}\n"
            closing += "\nThese are not technical recommendations but symbolic invitations—directions the code might grow to achieve greater internal coherence.\n"
        
        closing += """
---

*This interpretation was generated by Oneirocode, treating code as symbolic expression. It is not engineering advice but psychological exploration.*

*The dreamer must interpret their own dreams.*"""
        
        section_parts.append(closing)
        
        self.report_sections.append("\n".join(section_parts))

    def _create_strength_bar(self, value: float, width: int = 10) -> str:
        """Create a visual strength bar."""
        filled = int(value * width)
        empty = width - filled
        return f"[{'█' * filled}{'░' * empty}]"
